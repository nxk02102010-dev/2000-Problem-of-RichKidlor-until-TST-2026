https://oj.clue.edu.vn/problem/prevoi26_arrows


#include<bits/stdc++.h>
using namespace std;
#define F first
#define S second
#define U 0
#define D 1
#define L 2
#define R 3
#define IN(r, c) (((r) - 1) * m + (c))
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};
struct Ar{
    int fx,fy,tx,ty,type;
    Ar(){
        fx = fy = tx = ty = type = 0;
    }
    void init(){
        cin >> fx >> fy >> tx >> ty;
        if(fx == tx){
            type = fy < ty ? R : L;
        }
        else{
            type = fx < tx ? D : U;
        }
    }
};
const int MAX = 200100;
int n,m,k;
Ar ar[MAX];
int id[MAX];
vector<int> g[MAX],topo;
bool vis[MAX];
bool chk(int i,int j){return i >= 1 && j >= 1 && i <= n && j <= m;}
void init(){
    cin >> n >> m >> k;
    for(int i = 1;i <= k;i++){
        ar[i].init();
        int mX = ar[i].fx;
        int mY = ar[i].fy;
        int nX = ar[i].tx;
        int nY = ar[i].ty;
        if(mX > nX) swap(mX,nX);
        if(mY > nY) swap(mY,nY);
        for(int x = mX; x <= nX;x++) for(int y = mY;y <= nY;y++){
            assert(id[IN(x,y)] == 0);
            id[IN(x,y)] = i;
        }
    }
}
void dfs(int u){
    if(vis[u]) return;
    vis[u] = 1;
    for(int v : g[u]) dfs(v);
    topo.push_back(u);
}
void solve(void){
    for(int i = 1;i <= k;i++){
        int x = ar[i].tx + dx[ar[i].type];
        int y= ar[i].ty + dy[ar[i].type];
        while(chk(x,y)){
            if(id[IN(x,y)] > 0){
                int tk = id[IN(x,y)];
                g[i].push_back(tk);
                if(ar[i].type == ar[tk].type) break;
            }
            x += dx[ar[i].type];
            y += dy[ar[i].type];
        }
    }
    for(int i = 1;i <= k;i++) dfs(i);
    for(int x : topo) cout << x << ' ';
    cout << '\n';
}
int main(){
    //freopen("arrows.inp","r",stdin);
    //freopen("arrows.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    init();solve();
}
