Cho một bảng n × m cùng với k mũi tên song song với cạnh của bảng. Mỗi mũi tên sẽ đi qua một số ô của bảng và được biểu diễn
bởi 2 ô (x1
, y1),(x2
, y2) lần lượt là ô bắt đầu và kết thúc của mũi tên. Xét một mũi tên bắt đầu tại (x1
, y1) và kết thúc tại (x2
, y2), ta
định nghĩa:
● Mũi tên thuộc loại U nếu x1 > x2
, y1 = y2
.
● Mũi tên thuộc loại R nếu x1 = x2
, y1 < y2
.
● Mũi tên thuộc loại D nếu x1 < x2
, y1 = y2
.
● Mũi tên thuộc loại L nếu x1 = x2
, y1 > y2
.
Đề bài đảm bảo rằng cả k mũi tên đều thuộc 1 trong 4 loại trên. Dễ thấy mỗi mũi tên đều là một đoạn thẳng, mỗi mũi tên sẽ
"chiếm" mọi ô nằm trên đoạn thẳng của mũi tên, đề bài đảm bảo rằng mỗi ô chỉ bị "chiếm" bởi tối đa 1 mũi tên.
Nhiệm vụ của bạn là phải bỏ được tất cả k mũi tên ra khỏi bảng sau đúng k lượt chơi. Tại mỗi lượt chơi bạn sẽ được bỏ đúng một
mũi tên nếu mũi tên đó thoả mãn điều kiện dưới đây (giả sử mũi tên bắt đầu tại (x1
, y1) và kết thúc tại (x2
, y2)):
● Nếu mũi tên thuộc loại U, tất cả các ô (x, y) thoả mãn x < x2
, y = y2 đều không được phép bị "chiếm".
● Nếu mũi tên thuộc loại R, tất cả các ô (x, y) thoả mãn x = x2
, y > y2 đều không được phép bị "chiếm".
● Nếu mũi tên thuộc loại D, tất cả các ô (x, y) thoả mãn x > x2
, y = y2 đều không được phép bị "chiếm".
● Nếu mũi tên thuộc loại L, tất cả các ô (x, y) thoả mãn x = x2
, y < y2 đều không được phép bị "chiếm"


#include<bits/stdc++.h>
using namespace std;
#define F first
#define S second
#define U 0
#define D 1
#define L 2
#define R 3
#define IN(r, c) (((r) - 1) * m + (c))
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};
struct Ar{
    int fx,fy,tx,ty,type;
    Ar(){
        fx = fy = tx = ty = type = 0;
    }
    void init(){
        cin >> fx >> fy >> tx >> ty;
        if(fx == tx){
            type = fy < ty ? R : L;
        }
        else{
            type = fx < tx ? D : U;
        }
    }
};
const int MAX = 200100;
int n,m,k;
Ar ar[MAX];
int id[MAX];
vector<int> g[MAX],topo;
bool vis[MAX];
bool chk(int i,int j){return i >= 1 && j >= 1 && i <= n && j <= m;}
void init(){
    cin >> n >> m >> k;
    for(int i = 1;i <= k;i++){
        ar[i].init();
        int mX = ar[i].fx;
        int mY = ar[i].fy;
        int nX = ar[i].tx;
        int nY = ar[i].ty;
        if(mX > nX) swap(mX,nX);
        if(mY > nY) swap(mY,nY);
        for(int x = mX; x <= nX;x++) for(int y = mY;y <= nY;y++){
            assert(id[IN(x,y)] == 0);
            id[IN(x,y)] = i;
        }
    }
}
void dfs(int u){
    if(vis[u]) return;
    vis[u] = 1;
    for(int v : g[u]) dfs(v);
    topo.push_back(u);
}
void solve(void){
    for(int i = 1;i <= k;i++){
        int x = ar[i].tx + dx[ar[i].type];
        int y= ar[i].ty + dy[ar[i].type];
        while(chk(x,y)){
            if(id[IN(x,y)] > 0){
                int tk = id[IN(x,y)];
                g[i].push_back(tk);
                if(ar[i].type == ar[tk].type) break;
            }
            x += dx[ar[i].type];
            y += dy[ar[i].type];
        }
    }
    for(int i = 1;i <= k;i++) dfs(i);
    for(int x : topo) cout << x << ' ';
    cout << '\n';
}
int main(){
    //freopen("arrows.inp","r",stdin);
    //freopen("arrows.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    init();solve();
}
