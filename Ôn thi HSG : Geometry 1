Có N vị trí trên hệ trục tọa độ Oxy, chúng nối với nhau tạo thành 1 hình đa giác lồi. Có M truy vấn với mỗi truy vẫn cho 1 điểm và cần tìm xem điểm này có nằm trong đa giác hay không nếu có in ra 1
ngược lại in ra 0.


#include <bits/stdc++.h>
using namespace std;

#define int long long
#define F first
#define S second

int cross(const pair<int,int> &a,const pair<int,int> &b,const pair<int,int> &c)
{
    return (b.F - a.F) * (c.S - a.S) - (b.S - a.S) * (c.F - a.F);
}

bool onSeg(const pair<int,int> &a,const pair<int,int> &b,const pair<int,int> &p)
{return min(a.F, b.F) <= p.F && p.F <= max(a.F, b.F) && min(a.S, b.S) <= p.S && p.S <= max(a.S, b.S);}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<pair<int,int>> a(n);
    for(auto &p : a) cin >> p.F >> p.S;

    int m;
    cin >> m;

    while(m--){
        pair<int,int> M;
        cin >> M.F >> M.S;
        bool ok = 0;
        bool found = 0;
        bool inside = 1;

        for(int i = 0; i < n; i++){
            int cr = cross(a[i], a[(i+1)%n], M);
            if(cr == 0){
                if(!onSeg(a[i], a[(i+1)%n], M)){
                    inside = 0;
                    break;
                }
                continue;
            }
            if(!found){
                ok = (cr > 0);
                found = 1;
            }
            else{
                if((cr > 0) != ok){
                    inside = 0;
                    break;
                }
            }
        }

        cout << (inside ? 1 : 0) << '\n';
    }

    return 0;
}
