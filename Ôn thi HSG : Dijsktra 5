https://oj.vnoi.info/problem/vr_dijkstra_tunnel



#include<bits/stdc++.h>
using namespace std;
#define int long long
#define F first
#define S second
const int MAX = 100100,INF = 1e18;
struct E{
    int v,w,id;
};
vector<E> g[MAX],dag[MAX];
int n,m,ans = INF,A,B,C,D;
vector<int> distA,distB;
vector<int> dijsktra(int s,const vector<int> &free){
    vector<int> dist(n + 1,INF);
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
    q.push({0,s});
    dist[s] = 0;
    while(q.size()){
        auto top = q.top();
        q.pop();
        int u = top.S;
        int w1 = top.F;
        for(auto e : g[u]){
            int w2 = free[e.id] ? 0 : e.w;
            if(dist[e.v] > w1 + w2){
                dist[e.v] = w1 + w2;
                q.push({dist[e.v],e.v});
            }
        }
    }
    return dist;
}
vector<int> cur,freeE;
void dfs(int u){
    if(u == B){
        auto distC = dijsktra(C,freeE);
        ans = min(ans,distC[D]);
        return;
    }
    for(auto &e : dag[u]){
        freeE[e.id] = 1;
        dfs(e.v);
        freeE[e.id] = 0;
    }
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin >> n >> m;
    cin >> A >> B >> C >> D;
    for(int i = 0;i < m;i++){
        int a,b,c;cin >> a >> b >> c;
        g[a].push_back({b,c,i});
        g[b].push_back({a,c,i});
    }
    distA = dijsktra(A,vector<int>(m,0));
    distB = dijsktra(B,vector<int>(m,0));
    int shor = distA[B];
    for(int u = 1;u <= n;u++){
        for(auto &e : g[u]){
            if(distA[u] + e.w + distB[e.v] == shor){
                dag[u].push_back(e);
            }
        }
    }
    freeE.assign(m,0);
    dfs(A);
    cout << (ans == INF ? -1 : ans) << '\n';
}
